<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/docs/src/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/docs/src/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/basics/">-</a></li><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../Hecke/docs/src/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/docs/src/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/docs/src/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/docs/src/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/docs/src/finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../../Groups/groups/">Groups</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/docs/src/abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../Hecke/docs/src/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><span class="tocitem">Commutative Algebra</span><ul><li><a class="tocitem" href="../../CommutativeAlgebra/ca/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_rings/">Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_ideals/">Ideals in Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_modules/">Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_quotient_rings/">Quotient Rings of Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><span class="tocitem">Invariant Theory</span><ul><li><a class="tocitem" href="../../InvariantTheory/it/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/it_fg/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/it_lrg/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><span class="tocitem">Polyhedral Geometry</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a></li><li><a class="tocitem" href="../pg_polyhedra/">Polyhedra</a></li><li><a class="tocitem" href="../pg_linear_programs/">Linear programs</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Polyhedral Geometry</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/PolyhedralGeometry/pg.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Introduction">Introduction</a></li></ul><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Halfspaces" href="#Halfspaces"><code>Halfspaces</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Halfspaces</code></pre><p>Dummy type used for specifying the desired output format. Each halfspace <code>H(a,b)</code> is given by a vector <code>a</code> and a value <code>b</code> such that <span>$H(a,b) = \{ x\ |\ ax ≤ b \}.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="faces" href="#faces"><code>faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">faces(as::Type{T} = Polyhedron, P::Polyhedron, face_dim::Int)</code></pre><p>Return the faces of <code>P</code> of dimension <code>face_dim</code> as an iterator over the type of object given by <code>as</code>.</p><p>Optional arguments for <code>as</code> include</p><ul><li><code>Polyhedron</code>/<code>Polyhedra</code>.</li></ul><p><strong>Examples</strong></p><p>An <code>Array</code> containing the six sides of the 3-dimensional cube can be obtained via the following input:</p><pre><code class="language-julia-repl">julia&gt; F = faces(Polyhedron, cube(3), 2)
Oscar.PolyhedronFacePolyhedronIterator(A polyhedron in ambient dimension 3, 2)

julia&gt; collect(F)
6-element Array{Any,1}:
 A polyhedron in ambient dimension 3
 A polyhedron in ambient dimension 3
 A polyhedron in ambient dimension 3
 A polyhedron in ambient dimension 3
 A polyhedron in ambient dimension 3
 A polyhedron in ambient dimension 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L72-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vertices" href="#vertices"><code>vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertices(as::Type{T} = Points, P::Polyhedron)</code></pre><p>Return an iterator over the vertices of <code>P</code> in the format defined by <code>as</code>.</p><p>Optional arguments for <code>as</code> include</p><ul><li><code>Points</code>.</li></ul><p>See also: <a href="#vertices_as_point_matrix"><code>vertices_as_point_matrix</code></a>.</p><p><strong>Examples</strong></p><p>The following code computes the vertices of the Minkowski sum of a triangle and a square:</p><pre><code class="language-julia-repl">julia&gt; P = simplex(2) + cube(2);

julia&gt; collect(vertices(Points, P))
5-element Array{Polymake.Vector{Polymake.Rational},1}:
pm::Vector&lt;pm::Rational&gt;
-1 -1
pm::Vector&lt;pm::Rational&gt;
2 -1
pm::Vector&lt;pm::Rational&gt;
2 1
pm::Vector&lt;pm::Rational&gt;
-1 2
pm::Vector&lt;pm::Rational&gt;
1 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vertices_as_point_matrix" href="#vertices_as_point_matrix"><code>vertices_as_point_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertices_as_point_matrix(P::Polyhedron)</code></pre><p>Return a matrix whose rows are the vertices of <code>P</code>.</p><p><strong>Examples</strong></p><p>The following code computes the vertices of the Minkowski sum of a triangle and a square:</p><pre><code class="language-julia-repl">julia&gt; P = simplex(2) + cube(2);

julia&gt; vertices_as_point_matrix(P)
pm::Matrix&lt;pm::Rational&gt;
-1 -1
2 -1
2 1
-1 2
1 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nrays" href="#nrays"><code>nrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrays(C)</code></pre><p>Return the number of rays of the cone <code>C</code>.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>Here a cone is constructed from three rays. Calling <code>nrays</code> reveals that one of these was redundant:</p><pre><code class="language-julia-repl">julia&gt; R = [1 0; 0 1; 0 2];

julia&gt; PO = positive_hull(R);

julia&gt; nrays(PO)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L57-L75">source</a></section><section><div><pre><code class="nohighlight">nrays(P::Polyhedron)</code></pre><p>Return the number of rays of <code>P</code>.</p><p><strong>Examples</strong></p><p>Reflecting the input, the upper half-plane indeed has one ray.</p><pre><code class="language-julia-repl">julia&gt; UH = convex_hull([0 0],[0 1],[1 0]);

julia&gt; nrays(UH)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L258-L271">source</a></section><section><div><pre><code class="nohighlight">nrays(PF::PolyhedralFan)</code></pre><p>Returns the number of rays of a polyhedral fan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nvertices" href="#nvertices"><code>nvertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nvertices(P::Polyhedron)</code></pre><p>Return the number of vertices of <code>P</code>.</p><p><strong>Examples</strong></p><p>The 3-cube&#39;s number of vertices can be obtained with this input:</p><pre><code class="language-julia-repl">julia&gt; C = cube(3);

julia&gt; nvertices(C)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rays" href="#rays"><code>rays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rays(C)</code></pre><p>Return the rays of a cone.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>Here a cone is constructed from three rays. Calling <code>rays</code> reveals that one of these was redundant:</p><pre><code class="language-julia-repl">julia&gt; R = [1 0; 0 1; 0 2];

julia&gt; PO = positive_hull(R);

julia&gt; collect(rays(PO))
2-element Vector{Polymake.Vector{Polymake.Rational}}:
 pm::Vector&lt;pm::Rational&gt;
1 0
 pm::Vector&lt;pm::Rational&gt;
0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L22-L44">source</a></section><section><div><pre><code class="nohighlight">rays(as::Type{T} = Points, P::Polyhedron)</code></pre><p>Return minimal set of generators of the cone of unbounded directions of <code>P</code> (i.e. its rays)  in the format defined by <code>as</code>.</p><p>Optional arguments for <code>as</code> include</p><ul><li><code>Points</code>.</li></ul><p>See also <code>rays_as_point_matrix</code>.</p><p><strong>Examples</strong></p><p>We can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:</p><pre><code class="language-julia-repl">julia&gt; PO = convex_hull([0 0], [1 0; 0 1]);
julia&gt; collect(rays(Points, PO))
2-element Array{Polymake.Vector{Polymake.Rational},1}:
 pm::Vector&lt;pm::Rational&gt;
1 0
 pm::Vector&lt;pm::Rational&gt;
0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L291">source</a></section><section><div><pre><code class="nohighlight">rays(P::Polyhedron)</code></pre><p>Return minimal set of generators of the cone of unbounded directions of <code>P</code> (i.e. its rays)  as points.</p><p>See also <code>rays_as_point_matrix</code>.</p><p><strong>Examples</strong></p><p>We can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:</p><pre><code class="language-julia-repl">julia&gt; PO = convex_hull([0 0], [1 0; 0 1]);
julia&gt; collect(rays(PO))
2-element Array{Polymake.Vector{Polymake.Rational},1}:
 pm::Vector&lt;pm::Rational&gt;
1 0
 pm::Vector&lt;pm::Rational&gt;
0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L322">source</a></section><section><div><pre><code class="nohighlight">rays(PF::PolyhedralFan)</code></pre><p>Returns the rays of a polyhedral fan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nfacets" href="#nfacets"><code>nfacets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nfacets(P::Polyhedron)</code></pre><p>Return the number of facets of <code>P</code>.</p><p><strong>Examples</strong></p><p>The number of facets of the 5-dimensional cross polytope can be retrieved via the following line:</p><pre><code class="language-julia-repl">julia&gt; nfacets(cross(5))
32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L383-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="facets" href="#facets"><code>facets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">facets(as::Type{T} = Halfspaces, P::Polyhedron)</code></pre><p>Return the facets of <code>P</code> in the format defined by <code>as</code>.</p><p>The allowed values for <code>as</code> are</p><ul><li><code>Halfspaces</code>,</li><li><code>Polyhedron</code>/<code>Polyhedra</code>.</li></ul><p>See also <code>facets_as_halfspace_matrix_pair</code>.</p><p><strong>Examples</strong></p><p>We can retrieve the six facets of the 3-dimensional cube this way:</p><pre><code class="language-julia-repl">julia&gt; C = cube(3);

julia&gt; collect(facets(Polyhedron, C))
6-element Array{Any,1}:
A polyhedron in ambient dimension 3
A polyhedron in ambient dimension 3
A polyhedron in ambient dimension 3
A polyhedron in ambient dimension 3
A polyhedron in ambient dimension 3
A polyhedron in ambient dimension 3

julia&gt; collect(facets(Halfspaces, C))
6-element Array{Tuple{Polymake.Vector{Polymake.Rational},Polymake.Rational},1}:
(pm::Vector&lt;pm::Rational&gt;
-1 0 0, 1)
(pm::Vector&lt;pm::Rational&gt;
1 0 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 -1 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 1 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 0 -1, 1)
(pm::Vector&lt;pm::Rational&gt;
0 0 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L397">source</a></section><section><div><pre><code class="nohighlight">facets(P::Polyhedron)</code></pre><p>Return the facets of <code>P</code> as halfspaces.</p><p>See also <code>facets_as_halfspace_matrix_pair</code>.</p><p><strong>Examples</strong></p><p>We can retrieve the six facets of the 3-dimensional cube this way:</p><pre><code class="language-julia-repl">julia&gt; C = cube(3);

julia&gt; collect(facets(C))
6-element Array{Tuple{Polymake.Vector{Polymake.Rational},Polymake.Rational},1}:
(pm::Vector&lt;pm::Rational&gt;
-1 0 0, 1)
(pm::Vector&lt;pm::Rational&gt;
1 0 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 -1 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 1 0, 1)
(pm::Vector&lt;pm::Rational&gt;
0 0 -1, 1)
(pm::Vector&lt;pm::Rational&gt;
0 0 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="facets_as_halfspace_matrix_pair" href="#facets_as_halfspace_matrix_pair"><code>facets_as_halfspace_matrix_pair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">facets_as_halfspace_matrix_pair(P::Polyhedron)</code></pre><p>Return <code>(A,b)</code> such that <span>$P=P(A,b)$</span> where <span>$P(A,b) = \{ x |  Ax ≤ b \}.$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C = cube(3);

julia&gt; facets_as_halfspace_matrix_pair(C)
(A = pm::SparseMatrix&lt;pm::Rational, pm::NonSymmetric&gt;
(3) (0 -1)
(3) (0 1)
(3) (1 -1)
(3) (1 1)
(3) (2 -1)
(3) (2 1)
, b = pm::SparseVector&lt;pm::Rational&gt;
1 1 1 1 1 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="volume" href="#volume"><code>volume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">volume(P::Polyhedron)</code></pre><p>Return the (Euclidean) volume of <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C = cube(2);

julia&gt; volume(C)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L514-L526">source</a></section><section><div><pre><code class="language-julia">volume(L::AbsLat) -&gt; NfOrdFracIdl</code></pre><p>Returns the volume of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="normalized_volume" href="#normalized_volume"><code>normalized_volume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalized_volume(P::Polyhedron)</code></pre><p>Return the (normalized) volume of <code>P</code>`.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C = cube(2);

julia&gt; normalized_volume(C)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="dim" href="#dim"><code>dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dim(I::MPolyIdeal)</code></pre><p>Return the Krull dimension of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])

julia&gt; I = ideal(R, [y-x^2, x-z^3])
ideal generated by: -x^2 + y, x - z^3

julia&gt; dim(I)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/mpoly-ideals.jl#L982">source</a></section><section><div><pre><code class="language-julia">dim(a::MPolyQuoIdeal)</code></pre><p>Return the Krull dimension of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], ordering=:degrevlex)
(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])

julia&gt; Q, q = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]))
(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal generated by: x^3*y^2 - x^2*y^3, x*y^4 - x*y^2, Map from
Multivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal generated by: x^3*y^2 - x^2*y^3, x*y^4 - x*y^2 defined by a julia-function with inverse
)

julia&gt; I = ideal(Q,[x^3*y^4-x+y, x*y+y^2*x])
MPolyQuoIdeal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; dim(I)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/MPolyQuo.jl#L840">source</a></section><section><div><pre><code class="language-julia">dim(Q::MPolyQuo)</code></pre><p>Return the Krull dimension of the quotient ring <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])

julia&gt; Q, _ = quo(R, ideal(R, [y-x^2, x-z^3]))
(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal generated by: -x^2 + y, x - z^3, Map from
Multivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal generated by: -x^2 + y, x - z^3 defined by a julia-function with inverse
)

julia&gt; dim(Q)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/mpoly-affine-algebras.jl#L14">source</a></section><section><div><pre><code class="nohighlight">dim(C)</code></pre><p>Return the dimension of a cone.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>The cone <code>C</code> in this example is 2-dimensional within a 3-dimensional ambient space.</p><pre><code class="language-julia-repl">julia&gt; C = Cone([1 0 0; 1 1 0; 0 1 0]);

julia&gt; dim(C)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L78-L94">source</a></section><section><div><pre><code class="nohighlight">dim(P::Polyhedron)</code></pre><p>Return the dimension of <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];

julia&gt; P = convex_hull(V);

julia&gt; dim(P)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L544-L558">source</a></section><section><div><pre><code class="nohighlight">dim(PF::PolyhedralFan)</code></pre><p>Returns the dimension of a polyhedral fan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L71-L75">source</a></section><section><div><pre><code class="language-julia">dim(Y::YoungTableau) -&gt; BigInt</code></pre><p>Return the dimension (using hook-length formula) of the irreducible representation of permutation group <span>$S_n$</span> associated the partition <code>Y.part</code>.</p><p>Since the computation overflows easily <code>BigInt</code> is returned. You may perform the computation of the dimension in different type by calling <code>dim(Int, Y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dim(YoungTableau([4,3,1]))
70

julia&gt; dim(YoungTableau([3,1])) # the regular representation of S_4
3</code></pre></div></section><section><div><pre><code class="nohighlight">dim(M::FreeModule{T}) where T &lt;: FieldElement</code></pre><p>Return the dimension of the given vector space.</p></div></section><section><div><pre><code class="language-julia">dim(N::Submodule{T}) where T &lt;: FieldElement</code></pre><p>Return the dimension of the given vector subspace.</p></div></section><section><div><pre><code class="language-julia">dim(N::QuotientModule{T}) where T &lt;: FieldElement</code></pre><p>Return the dimension of the given vector quotient space.</p></div></section><section><div><pre><code class="language-julia">dim(V::AbsSpace) -&gt; Int</code></pre><p>Return the dimension of the space <code>V</code>.</p></div></section><section><div><pre><code class="nohighlight">dim(S::ZpGenus) -&gt; fmpz</code></pre><p>Return the dimension of this genus.</p></div></section><section><div><pre><code class="nohighlight">dim(G::ZGenus) -&gt; Int</code></pre><p>Return the dimension of this genus.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="lattice_points" href="#lattice_points"><code>lattice_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lattice_points(P::Polyhedron)</code></pre><p>Return the integer points contained in the bounded polyhedron <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S = 2 * simplex(2);

julia&gt; lattice_points(S)
6-element Array{Polymake.VectorAllocated{Polymake.Integer},1}:
 pm::Vector&lt;pm::Integer&gt;
0 0
 pm::Vector&lt;pm::Integer&gt;
0 1
 pm::Vector&lt;pm::Integer&gt;
0 2
 pm::Vector&lt;pm::Integer&gt;
1 0
 pm::Vector&lt;pm::Integer&gt;
1 1
 pm::Vector&lt;pm::Integer&gt;
2 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ambient_dim" href="#ambient_dim"><code>ambient_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ambient_dim(C)</code></pre><p>Return the ambient dimension of a cone.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>The cone <code>C</code> in this example is 2-dimensional within a 3-dimensional ambient space.</p><pre><code class="language-julia-repl">julia&gt; C = Cone([1 0 0; 1 1 0; 0 1 0]);

julia&gt; ambient_dim(C)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L97-L113">source</a></section><section><div><pre><code class="nohighlight">ambient_dim(P::Polyhedron)</code></pre><p>Return the ambient dimension of <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];

julia&gt; P = convex_hull(V);

julia&gt; ambient_dim(P)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L598">source</a></section><section><div><pre><code class="nohighlight">ambient_dim(PF::PolyhedralFan)</code></pre><p>Returns the ambient dimension of a polyhedral fan, which is the dimension of the embedding space. This is equal to the dimension of the fan if the fan is full-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="codim" href="#codim"><code>codim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codim(I::MPolyIdeal)</code></pre><p>Return the codimension of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])

julia&gt; I = ideal(R, [y-x^2, x-z^3])
ideal generated by: -x^2 + y, x - z^3

julia&gt; codim(I)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/mpoly-ideals.jl#L1011">source</a></section><section><div><pre><code class="nohighlight">codim(C)</code></pre><p>Returns the codimension of a cone.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>The cone <code>C</code> in this example is 2-dimensional within a 3-dimensional ambient space.</p><pre><code class="language-julia-repl">julia&gt; C = Cone([1 0 0; 1 1 0; 0 1 0]);

julia&gt; codim(C)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L116-L132">source</a></section><section><div><pre><code class="nohighlight">codim(P::Polyhedron)</code></pre><p>Return the codimension of <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];

julia&gt; P = convex_hull(V);

julia&gt; codim(P)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L615-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="lineality_space" href="#lineality_space"><code>lineality_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lineality_space(C)</code></pre><p>Return a basis of the lineality space of a cone.</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>Three rays are used here to construct the upper half-plane. Actually, two of these rays point in opposite directions. This gives us a 1-dimensional lineality.</p><pre><code class="language-julia-repl">julia&gt; UH = Cone([1 0; 0 1; -1 0]);

julia&gt; lineality_space(UH)
pm::Matrix&lt;pm::Rational&gt;
1 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L235-L253">source</a></section><section><div><pre><code class="nohighlight">lineality_space(P::Polyhedron)</code></pre><p>Return a matrix whose row span is the lineality space of <code>P</code>.</p><p><strong>Examples</strong></p><p>Despite not being reflected in this construction of the upper half-plane, its lineality in <span>$x$</span>-direction is recognized:</p><pre><code class="language-julia-repl">julia&gt; UH = convex_hull([0 0],[0 1; 1 0; -1 0]);

julia&gt; lineality_space(UH)
pm::Matrix&lt;pm::Rational&gt;
1 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L640">source</a></section><section><div><pre><code class="nohighlight">lineality_space(PF::PolyhedralFan)</code></pre><p>Returns the lineality_space of a polyhedral fan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="recession_cone" href="#recession_cone"><code>recession_cone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recession_cone(P::Polyhedron)</code></pre><p>Return the recession cone of <code>P</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = Polyhedron([1 -2; -1 1; -1 0; 0 -1],[2,1,1,1]);

julia&gt; collect(vertices(P))
3-element Array{Polymake.Vector{Polymake.Rational},1}:
 pm::Vector&lt;pm::Rational&gt;
0 -1
 pm::Vector&lt;pm::Rational&gt;
-1 0
 pm::Vector&lt;pm::Rational&gt;
-1 -1

julia&gt; recession_cone(P)
A polyhedral cone in ambient dimension 2

julia&gt; collect(rays(recession_cone(P)))
2-element Array{Polymake.Vector{Polymake.Rational},1}:
 pm::Vector&lt;pm::Rational&gt;
1 1/2
 pm::Vector&lt;pm::Rational&gt;
1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isfeasible" href="#isfeasible"><code>isfeasible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isfeasible(P::Polyhedron)</code></pre><p>Check whether <code>P</code> is feasible, i.e. non-empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = Polyhedron([1 -1; -1 1; -1 0; 0 -1],[-1,-1,1,1]);

julia&gt; isfeasible(P)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L693-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issmooth" href="#issmooth"><code>issmooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issmooth(P::Polyhedron)</code></pre><p>Check whether <code>P</code> is smooth.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C = cube(8);

julia&gt; issmooth(C)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L727-L739">source</a></section><section><div><pre><code class="nohighlight">issmooth(PF::PolyhedralFan)</code></pre><p>Determine whether the fan is smooth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/PolyhedralFan/properties.jl#L135-L139">source</a></section><section><div><pre><code class="nohighlight">issmooth(C::AffinePlaneCurve{S}, P::Point{S}) where S &lt;: FieldElem</code></pre><p>Throw an error if <code>P</code> is not a point of <code>C</code>, return <code>false</code> if <code>P</code> is a singular point of <code>C</code>, and <code>true</code> if <code>P</code> is a smooth point of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/experimental/PlaneCurve/AffinePlaneCurve.jl#L17">source</a></section><section><div><pre><code class="nohighlight">issmooth(C::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S &lt;: FieldElem</code></pre><p>Throw an error if <code>P</code> is not a point of <code>C</code>, return <code>false</code> if <code>P</code> is a singular point of <code>C</code>, and <code>true</code> if <code>P</code> is a smooth point of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/experimental/PlaneCurve/ProjPlaneCurve.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isnormal" href="#isnormal"><code>isnormal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnormal(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return whether the subgroup <code>H</code> is normal in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Groups/sub.jl#L234-L238">source</a></section><section><div><pre><code class="language-julia">isnormal(A::MPolyQuo)</code></pre><p>Given an affine algebra <code>A</code> over a perfect field, return <code>true</code> if <code>A</code> is normal, <code>false</code> otherwise.</p><p>CAVEAT: The function computes the normalization of <code>A</code>. This may take some time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/mpoly-affine-algebras.jl#L193">source</a></section><section><div><pre><code class="nohighlight">isnormal(P::Polyhedron)</code></pre><p>Check whether <code>P</code> is normal.</p><p><strong>Examples</strong></p><p>The 3-cube is normal.</p><pre><code class="language-julia-repl">julia&gt; C = cube(3)
A polyhedron in ambient dimension 3

julia&gt; isnormal(C)
true</code></pre><p>But this pyramid is not:</p><pre><code class="language-julia-repl">julia&gt; P = convex_hull([0 0 0; 0 1 1; 1 1 0; 1 0 1]);

julia&gt; isnormal(P)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L743-L764">source</a></section><section><div><pre><code class="nohighlight"> isnormal(K::AnticNumberField) -&gt; Bool</code></pre><p>Returns true if <span>$K$</span> is a normal extension of <span>$\mathbb Q$</span>, false otherwise.</p></div></section><section><div><pre><code class="language-julia">isnormal(C::ClassField) -&gt; Bool</code></pre><p>For a class field <span>$C$</span> defined over a normal base field <span>$k$</span>, decide if <span>$C$</span> is normal over <span>$Q$</span>.</p></div></section><section><div><pre><code class="nohighlight">isnormal(a::AlgAssAbsOrdIdl) -&gt; Bool</code></pre><p>Returns <code>true</code> if <span>$a$</span> is a normal ideal and <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isbounded" href="#isbounded"><code>isbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbounded(P::Polyhedron)</code></pre><p>Check whether <code>P</code> is bounded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = Polyhedron([1 -3; -1 1; -1 0; 0 -1],[1,1,1,1]);

julia&gt; isbounded(P)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L768-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isfulldimensional" href="#isfulldimensional"><code>isfulldimensional</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isfulldimensional(C)</code></pre><p>Determine whether the cone is full dimensional</p><p><strong>Arguments</strong></p><ul><li><code>C::Cone</code>: A cone.</li></ul><p><strong>Examples</strong></p><p>The cone <code>C</code> in this example is 2-dimensional within a 3-dimensional ambient space.</p><pre><code class="language-julia-repl">julia&gt; C = Cone([1 0 0; 1 1 0; 0 1 0]);

julia&gt; isfulldimensional(C)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Cone/properties.jl#L162-L178">source</a></section><section><div><pre><code class="nohighlight">isfulldimensional(P::Polyhedron)</code></pre><p>Check whether <code>P</code> is full dimensional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];

julia&gt; isfulldimensional(convex_hull(V))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L784-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="f_vector" href="#f_vector"><code>f_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f_vector(P::Polyhedron)</code></pre><p>Compute the vector <code>(f_1,f_2,...,f_(dim(P)-1))</code> where <code>f_i</code> is the number of faces of <code>P</code> of dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>Here we compute the f-vector of the 5-cube:</p><pre><code class="language-julia-repl">julia&gt; f_vector(cube(5))
5-element Array{Int64,1}:
 32
 80
 80
 40
 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="support_function" href="#support_function"><code>support_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_function(P::Polyhedron; convention::Symbol = :max)</code></pre><p>Produce a function <span>$h(ω) = max\{dot(x,ω)\ |\ x \in P\}$</span>. <span>$max$</span> may be changed to <span>$min$</span> by setting <code>convention = :min</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = cube(3) + simplex(3);

julia&gt; φ = support_function(P);

julia&gt; φ([1,2,3])
9

julia&gt; ψ = support_function(P, convention = :min);

julia&gt; ψ([1,2,3])
-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/properties.jl#L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="orbit_polytope" href="#orbit_polytope"><code>orbit_polytope</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">orbit_polytope(V, G)</code></pre><p>Construct the convex hull of the orbit of one or several points under the action of a permutation group.</p><p><strong>Arguments</strong></p><ul><li><code>V::AbstractVecOrMat</code>: Initial point(s).</li><li><code>P::PermGroup</code>: A permutation group.</li></ul><p><strong>Examples</strong></p><p>This will construct the <span>$3$</span>-dimensional permutahedron:</p><pre><code class="language-julia-repl">julia&gt; V = [1 2 3];

julia&gt; G = symmetric_group(3);

julia&gt; P = orbit_polytope(V, G)
A polyhedron in ambient dimension 3

julia&gt; collect(vertices(P))
6-element Vector{Polymake.Vector{Polymake.Rational}}:
 pm::Vector&lt;pm::Rational&gt;
1 2 3
 pm::Vector&lt;pm::Rational&gt;
1 3 2
 pm::Vector&lt;pm::Rational&gt;
2 1 3
 pm::Vector&lt;pm::Rational&gt;
2 3 1
 pm::Vector&lt;pm::Rational&gt;
3 1 2
 pm::Vector&lt;pm::Rational&gt;
3 2 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cube" href="#cube"><code>cube</code></a> — <span class="docstring-category">Function</span></header><section><div><p>cube(d , l = -1, u = 1)</p><p>Construct the <span>$[l,u]$</span>-cube in dimension <span>$d$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Int</code>: Dimension of the cube.</li><li><code>l::Rational</code>: Lower bound for each coordinate.</li><li><code>u::Rational</code>: Upper bound for each coordinate.</li></ul><p><strong>Examples</strong></p><p>In this example the 5-dimensional unit cube is constructed to ask for one of its properties:</p><pre><code class="language-julia-repl">julia&gt; C = cube(5,0,1);

julia&gt; normalized_volume(C)
120</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="newton_polytope" href="#newton_polytope"><code>newton_polytope</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newton_polytope(poly)</code></pre><p>Compute the Newton polytope of the given polynomial <code>poly</code>.</p><p><strong>Arguments</strong></p><ul><li><code>poly::Polynomial</code>: A multivariate polynomial.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Integer Ring, fmpz_mpoly[x, y])

julia&gt; f = x^3*y + 3x*y^2 + 1
x^3*y + 3*x*y^2 + 1

julia&gt; NP = newton_polytope(f)
A polyhedron in ambient dimension 2

julia&gt; collect(vertices(NP))
3-element Array{Polymake.Vector{Polymake.Rational},1}:
 pm::Vector&lt;pm::Rational&gt;
3 1
 pm::Vector&lt;pm::Rational&gt;
1 2
 pm::Vector&lt;pm::Rational&gt;
0 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L79-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="intersect" href="#intersect"><code>intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersect(V::T...) where T &lt;: Group
intersect(V::AbstractVector{T}) where T &lt;: Group</code></pre><p>If <code>V</code> = [<code>G_1</code>, ... , <code>G_n</code>], return the group intersection <code>K</code> of the groups <code>G_1</code>, ..., <code>G_n</code>, together with the embeddings <code>K</code> -&gt; <code>G_i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Groups/sub.jl#L364-L369">source</a></section><section><div><pre><code class="language-julia">intersect(V::AbstractVector{Union{T, GroupCoset, GroupDoubleCoset}}) where T &lt;: GAPGroup</code></pre><p>Return an array containing all elements belonging to all groups and cosets in the vector <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Groups/cosets.jl#L342-L346">source</a></section><section><div><pre><code class="language-julia">intersect(I::MPolyIdeal, Js::MPolyIdeal...)</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal generated by: x^3*y - x*y - y^3, x^4 - x^2 - x*y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/mpoly-ideals.jl#L132">source</a></section><section><div><pre><code class="language-julia">intersect(a::MPolyQuoIdeal, bs::MPolyQuoIdeal...)</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]))
(Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal generated by: x^2 - y^3, x - y, Map from
Multivariate Polynomial Ring in x, y over Rational Field to Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal generated by: x^2 - y^3, x - y defined by a julia-function with inverse
)

julia&gt; I = ideal(A, [y^2])
MPolyQuoIdeal(y^2)

julia&gt; J = ideal(A, [x])
MPolyQuoIdeal(x)

julia&gt; intersect(I,J)
MPolyQuoIdeal(x*y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Rings/MPolyQuo.jl#L188">source</a></section><section><div><pre><code class="nohighlight">intersect(P, Q)</code></pre><p>Intersect two polyhedra.</p><p><strong>Arguments</strong></p><ul><li><code>P::Polyhedron</code>: First polyhedron.</li><li><code>Q::Polyhedron</code>: Second polyhedron.</li></ul><p><strong>Examples</strong></p><p>The positive orthant of the plane is the intersection of the two halfspaces with <span>$x&gt;0$</span> and <span>$y&gt;0$</span> respectively.</p><pre><code class="language-julia-repl">julia&gt; UH1 = convex_hull([0 0],[1 0],[0 1]);

julia&gt; UH2 = convex_hull([0 0],[0 1],[1 0]);

julia&gt; PO = intersect(UH1, UH2)
A polyhedron in ambient dimension 2

julia&gt; collect(rays(PO))
2-element Vector{Polymake.Vector{Polymake.Rational}}:
 pm::Vector&lt;pm::Rational&gt;
1 0
 pm::Vector&lt;pm::Rational&gt;
0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L116">source</a></section><section><div><pre><code class="language-julia">Base.intersect(M::FPModule{T}, N::FPModule{T}) where T &lt;: RingElement</code></pre><p>Return the intersection of the modules <span>$M$</span> as a submodule of <span>$M$</span>. Note that <span>$M$</span> and <span>$N$</span> must be (constructed as) submodules (transitively) of some common module <span>$P$</span>.</p></div></section><section><div><pre><code class="nohighlight">intersect( C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}) where S &lt;: FieldElem</code></pre><p>Return the variety defined by the intersection of <code>C</code> and <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/experimental/PlaneCurve/AffinePlaneCurve.jl#L140">source</a></section><section><div><pre><code class="language-julia">intersect(mG::GrpAbFinGenMap, mH::GrpAbFinGenMap) -&gt; GrpAbFinGen, Map</code></pre><p>Given two injective maps of abelian groups with the same codomain <span>$G$</span>, return the intersection of the images as a subgroup of <span>$G$</span>.</p></div></section><section><div><pre><code class="nohighlight">intersect(a::NfRelOrdIdl, b::NfRelOrdIdl) -&gt; NfRelOrdIdl</code></pre><p>Returns <span>$a \cap b$</span>.</p></div></section><section><div><pre><code class="language-julia">intersect(x::NfOrdIdl, y::NfOrdIdl) -&gt; NfOrdIdl
lcm(x::NfOrdIdl, y::NfOrdIdl) -&gt; NfOrdIdl</code></pre><p>Returns <span>$x \cap y$</span>.</p></div></section><section><div><pre><code class="language-julia">intersect(a::ClassField, b::ClassField) -&gt; ClassField</code></pre><p>The intersection of <span>$a$</span> and <span>$b$</span> as a class field.</p></div></section><section><div><pre><code class="nohighlight">intersect(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -&gt; AlgAssAbsOrdIdl</code></pre><p>Returns <span>$a \cap b$</span>.</p></div></section><section><div><pre><code class="nohighlight">intersect(a::AlgAssRelOrdIdl, b::AlgAssRelOrdIdl) -&gt; AlgAssRelOrdIdl</code></pre><p>Returns <span>$a \cap b$</span>.</p></div></section><section><div><pre><code class="nohighlight">intersect(L::AbsLat, M::AbsLat) -&gt; AbsLat</code></pre><p>Returns the intersection of <span>$L$</span> and <span>$M$</span>.</p><p>The lattices <span>$L$</span> and <span>$M$</span> must have the same ambient space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="minkowski_sum" href="#minkowski_sum"><code>minkowski_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minkowski_sum(P::Polyhedron, Q::Polyhedron)</code></pre><p>Minkowski sum of two polyhedra.</p><p><strong>Arguments</strong></p><ul><li><code>P::Polyhedron</code>: First polyhedron.</li><li><code>Q::Polyhedron</code>: Second polyhedron.</li></ul><p><strong>Examples</strong></p><p>The Minkowski sum of a square and the 2-dimensional cross-polytope is an octagon:</p><pre><code class="language-julia-repl">julia&gt; P = cube(2);

julia&gt; Q = cross(2);

julia&gt; M = minkowski_sum(P, Q)
A polyhedron in ambient dimension 2

julia&gt; nvertices(M)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L148-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="+-Tuple{Polyhedron,Polyhedron}" href="#+-Tuple{Polyhedron,Polyhedron}"><code>+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(P::Polyhedron, Q::Polyhedron)</code></pre><p>Minkowski sum of two polyhedra.</p><p><strong>Arguments</strong></p><ul><li><code>P::Polyhedron</code>: First polyhedron.</li><li><code>Q::Polyhedron</code>: Second polyhedron.</li></ul><p><strong>Examples</strong></p><p>The Minkowski sum of a square and the 2-dimensional cross-polytope is an octagon:</p><pre><code class="language-julia-repl">julia&gt; P = cube(2);

julia&gt; Q = cross(2);

julia&gt; M = minkowski_sum(P, Q)
A polyhedron in ambient dimension 2

julia&gt; nvertices(M)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L186-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="*-Tuple{Polyhedron,Int64}" href="#*-Tuple{Polyhedron,Int64}"><code>*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(P::Polyhedron, k::Int)</code></pre><p>Return the scaled polyhedron <code>kP</code>. Note that <code>k*P = P*k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k::Int</code>: Scaling factor.</li><li><code>Q::Polyhedron</code>: A polyhedron.</li></ul><p><strong>Examples</strong></p><p>Scaling an <span>$n$</span>-dimensional bounded polyhedron by the factor <span>$k$</span> results in the volume being scaled by <span>$k^n$</span>. This example confirms the statement for the 6-dimensional cube and <span>$k = 2$</span>.</p><pre><code class="language-julia-repl">julia&gt; C = cube(6);

julia&gt; SC = C*2
A polyhedron in ambient dimension 6

julia&gt; volume(SC)//volume(C)
64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="*-Tuple{Int64,Polyhedron}" href="#*-Tuple{Int64,Polyhedron}"><code>*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(k::Int, Q::Polyhedron)</code></pre><p>Return the scaled polyhedron <code>kQ</code>. Note that <code>k*Q = Q*k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k::Int</code>: Scaling factor.</li><li><code>Q::Polyhedron</code>: A polyhedron.</li></ul><p><strong>Examples</strong></p><p>Scaling an <span>$n$</span>-dimensional bounded polyhedron by the factor <span>$k$</span> results in the volume being scaled by <span>$k^n$</span>. This example confirms the statement for the 6-dimensional cube and <span>$k = 2$</span>.</p><pre><code class="language-julia-repl">julia&gt; C = cube(6);

julia&gt; SC = 2*C
A polyhedron in ambient dimension 6

julia&gt; volume(SC)//volume(C)
64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="+-Tuple{Polyhedron,AbstractArray{T,1} where T}" href="#+-Tuple{Polyhedron,AbstractArray{T,1} where T}"><code>+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(P::Polyhedron, v::AbstractVector)</code></pre><p>Return the translation <code>P+v</code> of <code>P</code> by the vector <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>P::Polyhedron</code>: A polyhedron.</li><li><code>v::AbstractVector</code>: A vector of the same dimension as the ambient space of <code>P</code>.</li></ul><p><strong>Examples</strong></p><p>We construct a polyhedron from its <span>$V$</span>-description. Shifting it by the right vector reveals that its inner geometry corresponds to that of the 3-simplex.</p><pre><code class="language-julia-repl">julia&gt; P = convex_hull([100 200 300; 101 200 300; 100 201 300; 100 200 301]);

julia&gt; v = [-100, -200, -300];

julia&gt; S = P + v
A polyhedron in ambient dimension 3

julia&gt; collect(vertices(S))
4-element Vector{Polymake.Vector{Polymake.Rational}}:
 pm::Vector&lt;pm::Rational&gt;
0 0 0
 pm::Vector&lt;pm::Rational&gt;
1 0 0
 pm::Vector&lt;pm::Rational&gt;
0 1 0
 pm::Vector&lt;pm::Rational&gt;
0 0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="+-Tuple{AbstractArray{T,1} where T,Polyhedron}" href="#+-Tuple{AbstractArray{T,1} where T,Polyhedron}"><code>+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(v::AbstractVector,P::Polyhedron)</code></pre><p>Return the translation <code>v+P</code> of <code>P</code> by the vector <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>P::Polyhedron</code>: A polyhedron.</li><li><code>v::AbstractVector</code>: A vector of the same dimension as the ambient space of <code>P</code>.</li></ul><p><strong>Examples</strong></p><p>We construct a polyhedron from its <span>$V$</span>-description. Shifting it by the right vector reveals that its inner geometry corresponds to that of the 3-simplex.</p><pre><code class="language-julia-repl">julia&gt; P = convex_hull([100 200 300; 101 200 300; 100 201 300; 100 200 301]);

julia&gt; v = [-100, -200, -300];

julia&gt; S = v + P
A polyhedron in ambient dimension 3

julia&gt; collect(vertices(S))
4-element Vector{Polymake.Vector{Polymake.Rational}}:
 pm::Vector&lt;pm::Rational&gt;
0 0 0
 pm::Vector&lt;pm::Rational&gt;
1 0 0
 pm::Vector&lt;pm::Rational&gt;
0 1 0
 pm::Vector&lt;pm::Rational&gt;
0 0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cross" href="#cross"><code>cross</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cross(d[,n])</code></pre><p>Construct a <span>$d$</span>-dimensional cross polytope around origin with vertices located at <span>$\pm e_i$</span> for each unit vector <span>$e_i$</span> of <span>$R^d$</span>, scaled by <span>$n$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Int</code>: Dimension of the cross polytope (and its ambient space).</li><li><code>n::Scalar</code>: Scaling factor.</li></ul><p><strong>Examples</strong></p><p>Here we print the facets of a non-scaled and a scaled 3-dimensional cross polytope:</p><pre><code class="language-julia-repl">julia&gt; C = cross(3)
A polyhedron in ambient dimension 3

julia&gt; collect(facets(C))
8-element Vector{Tuple{Polymake.Vector{Polymake.Rational}, Polymake.Rational}}:
 (pm::Vector&lt;pm::Rational&gt;
1 1 1, 1)
 (pm::Vector&lt;pm::Rational&gt;
-1 1 1, 1)
 (pm::Vector&lt;pm::Rational&gt;
1 -1 1, 1)
 (pm::Vector&lt;pm::Rational&gt;
-1 -1 1, 1)
 (pm::Vector&lt;pm::Rational&gt;
1 1 -1, 1)
 (pm::Vector&lt;pm::Rational&gt;
-1 1 -1, 1)
 (pm::Vector&lt;pm::Rational&gt;
1 -1 -1, 1)
 (pm::Vector&lt;pm::Rational&gt;
-1 -1 -1, 1)

julia&gt; D = cross(3, 2)
A polyhedron in ambient dimension 3

julia&gt; collect(facets(D))
8-element Vector{Tuple{Polymake.Vector{Polymake.Rational}, Polymake.Rational}}:
 (pm::Vector&lt;pm::Rational&gt;
1 1 1, 2)
 (pm::Vector&lt;pm::Rational&gt;
-1 1 1, 2)
 (pm::Vector&lt;pm::Rational&gt;
1 -1 1, 2)
 (pm::Vector&lt;pm::Rational&gt;
-1 -1 1, 2)
 (pm::Vector&lt;pm::Rational&gt;
1 1 -1, 2)
 (pm::Vector&lt;pm::Rational&gt;
-1 1 -1, 2)
 (pm::Vector&lt;pm::Rational&gt;
1 -1 -1, 2)
 (pm::Vector&lt;pm::Rational&gt;
-1 -1 -1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="archimedean_solid" href="#archimedean_solid"><code>archimedean_solid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">archimedean_solid(s)</code></pre><p>Construct an Archimedean solid with the name given by String <code>s</code> from the list below.  The polytopes are realized with floating point numbers and thus not exact; Vertex-facet-incidences are correct in all cases.</p><p><strong>Arguments</strong></p><ul><li><p><code>s::String</code>: The name of the desired Archimedean solid.</p><p>Possible values:</p><pre><code class="nohighlight">&quot;truncated_tetrahedron&quot; : Truncated tetrahedron.
    Regular polytope with four triangular and four hexagonal facets.
&quot;cuboctahedron&quot; : Cuboctahedron.
    Regular polytope with eight triangular and six square facets.
&quot;truncated_cube&quot; : Truncated cube.
    Regular polytope with eight triangular and six octagonal facets.
&quot;truncated_octahedron&quot; : Truncated Octahedron.
    Regular polytope with six square and eight hexagonal facets.
&quot;rhombicuboctahedron&quot; : Rhombicuboctahedron.
    Regular polytope with eight triangular and 18 square facets.
&quot;truncated_cuboctahedron&quot; : Truncated Cuboctahedron.
    Regular polytope with 12 square, eight hexagonal and six octagonal
    facets.
&quot;snub_cube&quot; : Snub Cube.
    Regular polytope with 32 triangular and six square facets.
    The vertices are realized as floating point numbers.
    This is a chiral polytope.
&quot;icosidodecahedron&quot; : Icosidodecahedon.
    Regular polytope with 20 triangular and 12 pentagonal facets.
&quot;truncated_dodecahedron&quot; : Truncated Dodecahedron.
    Regular polytope with 20 triangular and 12 decagonal facets.
&quot;truncated_icosahedron&quot; : Truncated Icosahedron.
    Regular polytope with 12 pentagonal and 20 hexagonal facets.
&quot;rhombicosidodecahedron&quot; : Rhombicosidodecahedron.
    Regular polytope with 20 triangular, 30 square and 12 pentagonal
    facets.
&quot;truncated_icosidodecahedron&quot; : Truncated Icosidodecahedron.
    Regular polytope with 30 square, 20 hexagonal and 12 decagonal
    facets.
&quot;snub_dodecahedron&quot; : Snub Dodecahedron.
    Regular polytope with 80 triangular and 12 pentagonal facets.
    The vertices are realized as floating point numbers.
    This is a chiral polytope.</code></pre></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; T = archimedean_solid(&quot;cuboctahedron&quot;)
A polyhedron in ambient dimension 3

julia&gt; sum([nvertices(F) for F in faces(T, 2)] .== 3)
8

julia&gt; sum([nvertices(F) for F in faces(T, 2)] .== 4)
6

julia&gt; nfacets(T)
14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/1a6ae66ce8b8a48c5920df7bb4828162654fa651/src/Polytopes/Polyhedron/standard_constructions.jl#L465">source</a></section></article><p>The polyhedral geometry part of OSCAR provides functionality for handling</p><ul><li>convex polytopes, unbounded polyhedra and cones</li><li>linear programs</li></ul><p>General textbooks offering details on theory and algorithms include:</p><ul><li><a href="../../references/#JT13">Michael Joswig, Thorsten Theobald (2013)</a></li><li><a href="../../references/#Zie95">Günter M. Ziegler (1995)</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../InvariantTheory/it_lrg/">« Invariants of Linearly Reductive Groups</a><a class="docs-footer-nextpage" href="../pg_polyhedra/">Polyhedra »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Thursday 1 July 2021 18:11">Thursday 1 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
